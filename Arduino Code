#include <Servo.h>

// -----------------------------
// Hardware Pins
// -----------------------------
const int trigPin = 10;
const int echoPin = 11;
const int servoPin = 9;

// -----------------------------
// Scan Parameters
// -----------------------------
const int angleStart = 20;   // reduce noise near servo limits
const int angleEnd   = 160;
const int angleStep  = 5;
const int NUM_POINTS = (angleEnd - angleStart) / angleStep + 1;

// Distance storage
float distances[NUM_POINTS];

Servo servo;

// ----------------------------------------------------
// Read distance from HC-SR04
// ----------------------------------------------------
float readUltrasonic() {
  digitalWrite(trigPin, LOW);
  delayMicroseconds(2);
  digitalWrite(trigPin, HIGH);
  delayMicroseconds(10);
  digitalWrite(trigPin, LOW);

  long duration = pulseIn(echoPin, HIGH, 25000); // timeout 25ms
  if (duration == 0) return -1; // no echo

  float distance_cm = duration * 0.0343 / 2.0;
  return distance_cm;
}

// ----------------------------------------------------
// Classify the object using slope & variance analysis
// ----------------------------------------------------
void classifyObject() {

  // -----------------------------
  // 1. Compute mean & variance
  // -----------------------------
  float sum = 0;
  for (int i = 0; i < NUM_POINTS; i++) {
    sum += distances[i];
  }
  float mean = sum / NUM_POINTS;

  float varSum = 0;
  for (int i = 0; i < NUM_POINTS; i++) {
    varSum += (distances[i] - mean) * (distances[i] - mean);
  }
  float variance = varSum / NUM_POINTS;


  // -----------------------------
  // 2. Compute slopes & smoothness
  // -----------------------------
  int edgeCount = 0;
  int smoothCount = 0;

  for (int i = 2; i < NUM_POINTS; i++) {
    float slope = distances[i] - distances[i - 1];
    float prevSlope = distances[i - 1] - distances[i - 2];
    float jerk = abs(slope - prevSlope);   // change in slope

    if (abs(slope) > 12) edgeCount++;      // large jumps → edges
    if (jerk < 4) smoothCount++;           // low jerk → smooth curvature
  }


  // -----------------------------
  // 3. Classification logic
  // -----------------------------
  Serial.println("----- Classification Result -----");

  if (variance < 15) {
    Serial.println("Object Detected: FLAT SURFACE");
    Serial.println("--------------------------------");
    return;
  }

  if (edgeCount >= 2) {
    Serial.println("Object Detected: RECTANGULAR BOX");
    Serial.println("--------------------------------");
    return;
  }

  if (smoothCount > (NUM_POINTS * 0.6)) {
    Serial.println("Object Detected: SPHERE / CURVED OBJECT");
    Serial.println("--------------------------------");
    return;
  }

  Serial.println("Object Detected: UNKNOWN / COMPLEX SHAPE");
  Serial.println("--------------------------------");
}


// ----------------------------------------------------
// Perform one full scan left → right
// ----------------------------------------------------
void performScan() {
  int idx = 0;

  for (int a = angleStart; a <= angleEnd; a += angleStep) {
    servo.write(a);
    delay(120);  // allow servo to settle

    float d = readUltrasonic();
    if (d < 0 || d > 400) d = 400;  // bad readings → clamp

    distances[idx] = d;

    Serial.print("Angle: ");
    Serial.print(a);
    Serial.print("  Distance: ");
    Serial.println(d);

    idx++;
  }

  // After scan, analyze shape
  classifyObject();
}


// ----------------------------------------------------
// SETUP
// ----------------------------------------------------
void setup() {
  Serial.begin(9600);
  pinMode(trigPin, OUTPUT);
  pinMode(echoPin, INPUT);
  servo.attach(servoPin);
  delay(1000);

  Serial.println("Ultrasonic Object Classification Started");
}


// ----------------------------------------------------
// MAIN LOOP
// ----------------------------------------------------
void loop() {
  performScan();
  delay(2000); // wait a moment between scans
}
